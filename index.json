[{"content":"","date":"2025-11-02","externalUrl":null,"permalink":"/ProjectConsent/","section":"","summary":"","title":"","type":"page"},{"content":"\rIntroduction #\rIn the era of Web3, owning your content means more than just writing it â€” it means truly controlling where and how it lives. By combining the Blowfish theme (a beautiful, modern Hugo theme) with Unstoppable Domains (UD) and IPFS, you can create a fully decentralized, censorship-resistant blog thatâ€™s as easy to update as a traditional site â€” but lives forever on the blockchain.\nThis guide walks you through setting up a Node.js + Hugo + Blowfish stack on Linux, generating a static site, and publishing it to IPFS via Unstoppable Domains â€” all in under 30 minutes.\nPrerequisites #\rWeâ€™ll install:\nNode.js (v22.20.0) â€“ for Blowfish tools Git â€“ version control Go (1.25.1) â€“ required by some Hugo tools Hugo (via Snap) â€“ static site generator Dart Sass â€“ included in Hugo Snap (no separate install needed) Step 0: Get Your Unstoppable Domain #\rGo to unstoppabledomains.com Buy a domain like myblog.brave or decentralized.brave Step 1: Install Dependencies (One-Shot Setup) #\rOpen your terminal and run these commands one after another:\n# Update system sudo apt update # Install Git sudo apt install git -y # Install Node.js v22.20.0 wget https://nodejs.org/dist/v22.20.0/node-v22.20.0-linux-x64.tar.xz sudo tar -C /usr/local -xJf node-v22.20.0-linux-x64.tar.xz # Install Go 1.25.1 wget https://dl.google.com/go/go1.25.1.linux-amd64.tar.gz sudo rm -rf /usr/local/go sudo tar -C /usr/local -xzf go1.25.1.linux-amd64.tar.gz # Add Node.js and Go to PATH (one-liner) echo \u0026#39;export PATH=$PATH:/usr/local/node-v22.20.0-linux-x64/bin:/usr/local/go/bin\u0026#39; \u0026gt;\u0026gt; $HOME/.profile source $HOME/.profile # Install Hugo via Snap (includes Dart Sass) sudo snap install hugo Pro Tip: After running source $HOME/.profile, verify installations:\nnode -v # â†’ v22.20.0 go version # â†’ go1.25.1 hugo version # â†’ hugo v0.x.x Step 2: Create Your Blog with Blowfish #\rBlowfish provides a CLI tool to scaffold a new Hugo site with the theme pre-installed.\nnpx blowfish-tools new my-web3-blog cd my-web3-blog This creates a fully functional Hugo site with Blowfish theme, sample content, and config.\nStep 3: Configure Hugo for IPFS (Relative URLs) #\rEdit the main config file:\nnano hugo.toml Add or update these lines:\nrelativeURLs = true baseURL = \u0026#34;/\u0026#34; relativeURLs = true ensures all links (CSS, JS, images) use relative paths â€” critical for IPFS.\nbaseURL = \u0026quot;/\u0026quot; lets the site work from any domain or gateway.\nSave and exit (Ctrl+O â†’ Enter â†’ Ctrl+X).\nStep 4: Write Your First Post #\rhugo new posts/my-first-web3-post.md Edit the file:\nnano content/posts/my-first-web3-post.md Add front matter and content:\n--- title: \u0026#34;Welcome to My Decentralized Blog\u0026#34; date: 2025-11-02 draft: false --- This blog is hosted on **IPFS** and resolved via **Unstoppable Domains**. No servers. No takedowns. Just freedom. Step 5: Build \u0026amp; Preview Locally #\rhugo server Visit http://localhost:1313 â€” your blog is live locally!\nStep 6: Build for Production #\rhugo --minify This generates the static site in the public/ folder.\nStep 7: Publish to IPFS via Unstoppable Domains #\rOption A: Using Unstoppable Domains (Recommended â€“ Easiest) #\rGo to My Domains on unstoppabledomains.com Select your domain (e.g., myblog.brave) Click \u0026ldquo;Website\u0026rdquo; Click \u0026ldquo;Upload website files to IPFS\u0026rdquo; Drag your entire public/ folder (not individual files) into the upload window Click Launch Website Your site is now live on IPFS and accessible at your domain.\nTo update later: Rebuild with hugo --minify, then re-upload the new public/ folder. UD will generate a new CID and update your domain automatically.\nOption B: Using Pinata (For Power Users) #\rSign up at pinata.cloud Get your JWT from the API keys section Install Pinata CLI: npm install -g @pinata/sdk Deploy: pinata deploy public/ --key YOUR_JWT_KEY Copy the returned CID (e.g., QmExample123...) In UD domain management: Add a Website Record Set type: ipfs Value: Your CID Your site is now live at:\nhttps://myblog.brave\nWhy This Stack Rocks #\rFeature Benefit Blowfish Theme Stunning, customizable, dark mode Hugo Blazing fast static sites IPFS Immutable, distributed hosting Unstoppable Domains Human-readable .brave URLs No Servers Zero maintenance, zero cost Resources #\rBlowfish Theme: https://blowfish.page Hugo Docs: https://gohugo.io Unstoppable Domains: https://unstoppabledomains.com Final Thoughts #\rYou now own a truly decentralized blog. No hosting bills. No domain seizures. No middlemen.\nWrite freely. Publish forever.\nYour Web3 Blog is Live\nBuilt with ðŸ’š using Blowfish + Hugo + IPFS + UD\n","date":"2025-11-02","externalUrl":null,"permalink":"/ProjectConsent/posts/202511-blowfish-ud/","section":"Posts","summary":"\u003ch2 class=\"relative group\"\u003eIntroduction \r\n    \u003cdiv id=\"introduction\" class=\"anchor\"\u003e\u003c/div\u003e\r\n    \r\n    \u003cspan\r\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\r\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#introduction\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\r\n    \u003c/span\u003e        \r\n    \r\n\u003c/h2\u003e\r\n\u003cp\u003eIn the era of Web3, owning your content means more than just writing it â€” it means \u003cem\u003etruly controlling where and how it lives\u003c/em\u003e. By combining the \u003cstrong\u003eBlowfish theme\u003c/strong\u003e (a beautiful, modern Hugo theme) with \u003cstrong\u003eUnstoppable Domains (UD)\u003c/strong\u003e and \u003cstrong\u003eIPFS\u003c/strong\u003e, you can create a fully decentralized, censorship-resistant blog thatâ€™s as easy to update as a traditional site â€” but lives forever on the blockchain.\u003c/p\u003e","title":"Blowfish + UD: Build your own Web3 Blog","type":"posts"},{"content":"","date":"2025-11-02","externalUrl":null,"permalink":"/ProjectConsent/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025-11-02","externalUrl":null,"permalink":"/ProjectConsent/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-11-02","externalUrl":null,"permalink":"/ProjectConsent/tags/web3/","section":"Tags","summary":"","title":"Web3","type":"tags"},{"content":"Image File Execution Options (IFEO) is a powerful Windows registry feature for debugging, but it often leads to headachesâ€”like infinite loops when your process tries to launch an IFEO-configured executable. You\u0026rsquo;ve probably seen advice to use DEBUG_PROCESS flags and detach immediately, but that requires messy debug code.\nToday, I\u0026rsquo;m revealing a cleaner secret: Hook NtCreateUserProcess with Detours to set the IFEOSkipDebugger flag (0x00000004) in the process creation info. This skips the IFEO debugger entirely for that launch.\nBonus: We\u0026rsquo;ll also cover getting/setting parent process IDsâ€”handy for advanced scenarios like spoofing parents to evade detection.\nSetting Up IFEO via Registry #\rTo enable IFEO for a specific executable (e.g., something.exe), run this as admin:\nREG ADD \u0026#34;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\something.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;X:\\path\\to\\IFEOSkipDebugger.exe\u0026#34; /f This sets a debugger to launch instead of something.exe. For more granularity, use subkeys under the path for named processes.\nBut how do you launch something.exe from your app without triggering an infinite loop? Enter the hook.\nThe Secret: Hooking NtCreateUserProcess with Detours #\rBy intercepting NtCreateUserProcess and tweaking the InitFlags in PsCreateInitialState, we force IFEOSkipDebugger.\n#include \u0026#34;include/detours.h\u0026#34; #ifdef _WIN64 #pragma comment(lib, \u0026#34;lib.X64/detours.lib\u0026#34;) #else #pragma comment(lib, \u0026#34;lib.X86/detours.lib\u0026#34;) #endif typedef NTSTATUS(NTAPI *PNTCREATEUSERPROCESS)(PHANDLE ProcessHandle, PHANDLE ThreadHandle, // ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, // PVOID ProcessObjectAttributes, PVOID ThreadObjectAttributes, // DWORD ProcessFlags, DWORD ThreadFlags, // PVOID ProcessParameters, PVOID CreateInfo, PVOID AttributeList); PNTCREATEUSERPROCESS p_NtCreateUserProcess; NTSTATUS NTAPI NewNtCreateUserProcess(PHANDLE ProcessHandle, PHANDLE ThreadHandle, // ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, // PVOID ProcessObjectAttributes, PVOID ThreadObjectAttributes, // DWORD ProcessFlags, DWORD ThreadFlags, // PVOID ProcessParameters, PVOID CreateInfo, PVOID AttributeList) { auto p = (PBYTE)CreateInfo; #ifdef _WIN64 if (*(ULONG *)\u0026amp;p[8] == 0) // PsCreateInitialState { auto \u0026amp;InitFlags = *(ULONG *)\u0026amp;p[16]; InitFlags |= 0x00000004; // IFEOSkipDebugger } #else if (*(ULONG *)\u0026amp;p[4] == 0) // PsCreateInitialState { auto \u0026amp;InitFlags = *(ULONG *)\u0026amp;p[8]; InitFlags |= 0x00000004; // IFEOSkipDebugger } #endif return p_NtCreateUserProcess(ProcessHandle, ThreadHandle, // ProcessDesiredAccess, ThreadDesiredAccess, // ProcessObjectAttributes, ThreadObjectAttributes, // ProcessFlags, ThreadFlags, // ProcessParameters, CreateInfo, AttributeList); } Wrap your CreateProcessW call with Detours attach/detach:\nDetourTransactionBegin(); DetourAttach(\u0026amp;(PVOID \u0026amp;)p_NtCreateUserProcess, NewNtCreateUserProcess); DetourTransactionCommit(); BOOL result = CreateProcessW(/* ... */); DetourTransactionBegin(); DetourDetach(\u0026amp;(PVOID \u0026amp;)p_NtCreateUserProcess, NewNtCreateUserProcess); DetourTransactionCommit(); Why This Works #\rNtCreateUserProcess is the low-level API for user-mode process creation. We modify CreateInfo (a PS_CREATE_INFO structure) to set IFEOSkipDebugger in InitFlags. This flag tells the kernel to ignore IFEO\u0026rsquo;s Debugger value for this spawn. Bonus perk: Bypasses Windows 10/11 app aliases (e.g., python.exe) that might trigger unwanted redirects. No debug privileges needed. No infinite loops. Clean and efficient.\nBonus: Get/Set Process Parent ID #\rGetting the Parent Process ID #\rUse NtQueryInformationProcess for the current process\u0026rsquo;s parent PID:\nDWORD GetParentProcessId() { PROCESS_BASIC_INFORMATION pbi{}; ULONG retLen = 0; if (NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, \u0026amp;pbi, sizeof(pbi), \u0026amp;retLen))) { auto InheritedFromUniqueProcessId = (DWORD)(ULONG_PTR)pbi.Reserved3; return InheritedFromUniqueProcessId; } return 0; } Setting (Spoofing) the Parent Process #\rTo spoof the parent when creating a child process:\ntemplate \u0026lt;typename T, typename Deleter\u0026gt; auto make_unique_with_deleter(T *ptr, Deleter deleter) { return std::unique_ptr\u0026lt;T, Deleter\u0026gt;(ptr, deleter); } HANDLE hParentProcess = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, dwParentProcessId); if (!hParentProcess) { // } auto hParentProcessUP = make_unique_with_deleter(\u0026amp;hParentProcess, [](auto *ptr) { CloseHandle(*ptr); }); SIZE_T attrListSize = 0; InitializeProcThreadAttributeList(NULL, 1, 0, \u0026amp;attrListSize); auto attrListBufUP = std::make_unique\u0026lt;BYTE[]\u0026gt;(attrListSize); auto attrList = (LPPROC_THREAD_ATTRIBUTE_LIST)attrListBufUP.get(); if (!InitializeProcThreadAttributeList(attrList, 1, 0, \u0026amp;attrListSize)) { // } auto attrListUP = make_unique_with_deleter(\u0026amp;attrList, [](auto *ptr) { DeleteProcThreadAttributeList(*ptr); }); if (!UpdateProcThreadAttribute(attrList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, \u0026amp;hParentProcess, sizeof(hParentProcess), NULL, NULL)) { // } Pass this attribute list to CreateProcess via STARTUPINFOEX.lpAttributeList.\nThis is often used in red teaming to make child processes appear spawned by benign parents (e.g., explorer.exe), evading EDR tools.\nWhy This Matters #\rIFEO is great for global hooks/debuggers, but self-launching breaks things. This technique keeps your tools flexible without complexity.\nFor parent spoofing: Essential for stealth in security research or custom launchers.\nReferences #\rGeoff Chappell: PS_CREATE_INFO Detours: Microsoft Research Happy low-level hacking\n","date":"2025-10-05","externalUrl":null,"permalink":"/ProjectConsent/posts/202510-demystifying-ifeo/","section":"Posts","summary":"\u003cp\u003eImage File Execution Options (IFEO) is a powerful Windows registry feature for debugging, but it often leads to headachesâ€”like infinite loops when your process tries to launch an IFEO-configured executable. You\u0026rsquo;ve probably seen advice to use \u003ccode\u003eDEBUG_PROCESS\u003c/code\u003e flags and detach immediately, but that requires messy debug code.\u003c/p\u003e","title":"Demystifying IFEO: Launching Processes Without Infinite Debugger Loops","type":"posts"},{"content":"","date":"2025-10-05","externalUrl":null,"permalink":"/ProjectConsent/tags/redteaming/","section":"Tags","summary":"","title":"RedTeaming","type":"tags"},{"content":"","date":"2025-10-05","externalUrl":null,"permalink":"/ProjectConsent/tags/windowsinternals/","section":"Tags","summary":"","title":"WindowsInternals","type":"tags"},{"content":"","date":"2025-01-16","externalUrl":null,"permalink":"/ProjectConsent/tags/cprogramming/","section":"Tags","summary":"","title":"CProgramming","type":"tags"},{"content":"","date":"2025-01-16","externalUrl":null,"permalink":"/ProjectConsent/tags/reverseengineering/","section":"Tags","summary":"","title":"ReverseEngineering","type":"tags"},{"content":"Sometimes, the most powerful tools are the ones you build yourself.\nToday, Iâ€™m sharing a minimal, self-contained C program that demonstrates how to walk the Windows NT Loaderâ€™s in-memory module lists and extract loaded DLLs â€” without using EnumProcessModules or CreateToolhelp32Snapshot.\nWeâ€™ll also peek into the console subsystem to list all processes attached to the current console using GetConsoleProcessList.\nUse case: Debugging, reverse engineering, anti-cheat systems, or just understanding how Windows really loads your process.\nThe Code (Copy-Paste Ready) #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; VOID PrintDllNameFromInLoadOrderModuleList() { int i = 0; LIST_ENTRY *ListEntryHead = \u0026amp;NtCurrentTeb()-\u0026gt;ProcessEnvironmentBlock-\u0026gt;Ldr-\u0026gt;InMemoryOrderModuleList - 1; for (LIST_ENTRY *ListEntry = ListEntryHead-\u0026gt;Flink; ListEntry != ListEntryHead; ListEntry = ListEntry-\u0026gt;Flink) { LDR_DATA_TABLE_ENTRY *LdrDataTableEntry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, Reserved1); UNICODE_STRING *DllName = \u0026amp;LdrDataTableEntry-\u0026gt;FullDllName; printf(\u0026#34;InLoadOrderModuleList[%d] %wZ\\n\u0026#34;, i++, \u0026amp;DllName[0]); } } VOID PrintDllNameFromInMemoryOrderModuleList() { int i = 0; LIST_ENTRY *ListEntryHead = \u0026amp;NtCurrentTeb()-\u0026gt;ProcessEnvironmentBlock-\u0026gt;Ldr-\u0026gt;InMemoryOrderModuleList; for (LIST_ENTRY *ListEntry = ListEntryHead-\u0026gt;Flink; ListEntry != ListEntryHead; ListEntry = ListEntry-\u0026gt;Flink) { LDR_DATA_TABLE_ENTRY *LdrDataTableEntry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); UNICODE_STRING *DllName = \u0026amp;LdrDataTableEntry-\u0026gt;FullDllName; printf(\u0026#34;InMemoryOrderModuleList[%d] %wZ\\n\u0026#34;, i++, \u0026amp;DllName[0]); } } VOID PrintDllNameFromInInitializationOrderModuleList() { int i = 0; LIST_ENTRY *ListEntryHead = \u0026amp;NtCurrentTeb()-\u0026gt;ProcessEnvironmentBlock-\u0026gt;Ldr-\u0026gt;InMemoryOrderModuleList + 1; for (LIST_ENTRY *ListEntry = ListEntryHead-\u0026gt;Flink; ListEntry != ListEntryHead; ListEntry = ListEntry-\u0026gt;Flink) { LDR_DATA_TABLE_ENTRY *LdrDataTableEntry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, Reserved2); UNICODE_STRING *DllName = \u0026amp;LdrDataTableEntry-\u0026gt;FullDllName; printf(\u0026#34;InInitializationOrderModuleList[%d] %wZ\\n\u0026#34;, i++, \u0026amp;DllName[0]); } } VOID PrintFullProcessImageNameFromConsoleProcessList() { DWORD dwProcessList[260]{}; DWORD dwProcessCount; dwProcessCount = GetConsoleProcessList(dwProcessList, ARRAYSIZE(dwProcessList)); if (!dwProcessCount || dwProcessCount \u0026gt; ARRAYSIZE(dwProcessList)) return; for (DWORD i = 0; i != dwProcessCount; i++) { HANDLE hProcess; CHAR ExeName[MAX_PATH]{}; DWORD dwSize = ARRAYSIZE(ExeName); hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessList[i]); if (!hProcess) continue; if (!QueryFullProcessImageNameA(hProcess, 0, ExeName, \u0026amp;dwSize)) continue; printf(\u0026#34;ConsoleProcessList[%d] %10d %.*s\\n\u0026#34;, i, dwProcessList[i], dwSize, ExeName); } } int main() { PrintDllNameFromInLoadOrderModuleList(); PrintDllNameFromInMemoryOrderModuleList(); PrintDllNameFromInInitializationOrderModuleList(); PrintFullProcessImageNameFromConsoleProcessList(); return 0; } What Youâ€™ll See #\rInLoadOrderModuleList[0] C:\\path\\to\\something.exe\rInLoadOrderModuleList[0] C:\\path\\to\\something.dll\r...\rConsoleProcessList[0] 1234 C:\\Windows\\System32\\cmd.exe\rConsoleProcessList[1] 5678 C:\\path\\to\\something.exe Why These Three Lists? #\rList Purpose Offset Field InLoadOrderModuleList Modules in load order (exe first) Reserved1 InMemoryOrderModuleList Modules in memory layout order InMemoryOrderLinks InInitializationOrderModuleList Order of DllMain calls Reserved2 Note: These structures are undocumented but stable across Windows 10/11.\nBonus: GetConsoleProcessList #\rReturns all PIDs attached to the current console Great for parent/child process detection in CLI tools References #\rNT Internals ReactOS Source GetConsoleProcessList - MSDN Final Thoughts #\rThis snippet is a perfect drop-in for:\nMalware analysis sandboxes Game cheat engines Custom debuggers Learning Windows internals No dependencies. No bloat. Just raw NT power.\nHappy hacking\n","date":"2025-01-16","externalUrl":null,"permalink":"/ProjectConsent/posts/202501-traversing-windows/","section":"Posts","summary":"\u003cp\u003eSometimes, the most powerful tools are the ones you build yourself.\u003c/p\u003e\n\u003cp\u003eToday, Iâ€™m sharing a \u003cstrong\u003eminimal, self-contained C program\u003c/strong\u003e that demonstrates how to walk the \u003cstrong\u003eWindows NT Loaderâ€™s in-memory module lists\u003c/strong\u003e and extract loaded DLLs â€” \u003cstrong\u003ewithout using \u003ccode\u003eEnumProcessModules\u003c/code\u003e or \u003ccode\u003eCreateToolhelp32Snapshot\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Traversing Windows Loader Structures: Enumerating DLLs \u0026 Console Processes","type":"posts"},{"content":"","externalUrl":null,"permalink":"/ProjectConsent/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ProjectConsent/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/ProjectConsent/series/","section":"Series","summary":"","title":"Series","type":"series"}]